## Research Doc

1. **Требования** к задаче.  
2. **Как они выполнены** в решении.  
3. **Используемые библиотеки и инструменты**.  
4. **Описание самодельного барьера**.  
5. **Тестирование**.
6. **Вывод**.

---

# 1. Цели и требования курсового проекта

Согласно заданию, нужно написать программу на C++, которая:

1. **Принимает DAG (Directed Acyclic Graph) «джоб»** из INI-файла и **проверяет корректность**:
   - отсутствие циклов,
   - единственная компонента связности,
   - хотя бы одна стартовая и одна финишная «джоба».
2. **Выполняет джобы** с учётом зависимостей (DAG).  
   - Если **одна джоба «упала»** (завершилась с ошибкой), нужно **прервать** выполнение всего DAG.
3. **Максимальный параллелизм**: запускаем не более \(N\) джоб одновременно (значение берётся из параметра `[Parallel]`).
4. **Синхронизация через «барьеры»**: несколько джоб могут принадлежать одному барьеру, и зависящие джобы не могут стартовать, пока **все джобы** данного барьера не завершатся.

---

# 2. Архитектура решения

Решение разбито на три файла:
1. `dag.h`,
2. `dag.cpp` (реализация класса `TDagExecutor`),
3. `main.cpp`.

Дополнительно мы имеем:
- `CP_test.cpp` (Google Test) для тестирования.

## 2.1. Класс **`TDagExecutor`**

Весь основной функционал по выполнению DAG инкапсулирован в классе `TDagExecutor`. Он хранит:

- **`std::map<int, TJob> Jobs_`**: все «джобы», где `TJob` содержит:
  - `JobId`,
  - `BarrierName`,
  - списки `Dependencies` и `Children`,
  - атомик `RemainDeps` (сколько зависимостей осталось невыполненными),
  - атомики `IsFinished`, `IsSuccess`.
- **`std::map<std::string, TBarrierGroup> BarrierGroups_`**: каждый барьер (по имени) содержит:
  - `Remaining` (сколько джоб в этом барьере ещё не завершилось),
  - `pthread_mutex_t` и `pthread_cond_t`.
- **`std::queue<int> ReadyQueue_`**: очередь «готовых» к запуску джоб.
- Параметр **`MaxParallel_`**: максимальное число параллельных джоб.
- **`StopExecution_`** (atomic bool): если хотя бы одна джоба упала — ставим `true`.
- Механизмы синхронизации:  
  - `pthread_mutex_t QueueMutex_` и `pthread_cond_t QueueCond_` для управления `ReadyQueue_`.  
  - глобальный мьютекс `g_PrintMutex` для потокобезопасного вывода.

## 2.2. Процесс выполнения

1. **Чтение INI**: метод `ReadIni()` парсит `[Jobs]`, `[Edges]`, `[Parallel]`.  
   - Для `[Jobs]`: создаём `TJob`, записываем в `Jobs_`.  
   - Для `[Edges]`: связываем `Children` и `Dependencies`.  
   - `[Parallel]` задаёт `MaxParallel_`.  
   - Вычисляем `RemainDeps` и создаём «барьеры» — `BarrierGroups_`, если есть `BarrierName`.  
2. **Проверка DAG**:
   - `CheckCycle()` — DFS и «рекурсивный стек» для обнаружения цикла.  
   - `CheckStartFinish()` — проверяет, есть ли хотя бы одна джоба без зависимостей (start) и хотя бы одна джоба без детей (finish).  
3. **Запуск**: метод `RunDAG()`:
   - Добавляем в `ReadyQueue_` все джобы, у которых `RemainDeps == 0` (стартовые), **без** проверки барьера (иначе они никогда не запустятся).  
   - В цикле диспетчер:
     - Ждёт, пока появятся «готовые» джобы **или** освободятся потоки **или** сработает `StopExecution_`.  
     - Запускает новые потоки, пока не достигнем `MaxParallel_`.  
4. **Выполнение джобы**: метод `JobRunner()` (статическая функция, запускаемая в `pthread_create()`):
   - Имитирует работу (`sleep` 1..3 сек).  
   - Случайным образом «падает» для теста (нечётные jobId в 1/5 случаев).  
   - Если упала — `StopExecution_ = true`.  
   - По окончании вызывает `BarrierArrive()`, уменьшая `Remaining` в группе, и если дошли до 0 — `pthread_cond_broadcast()`.  
   - Если всё успешно, «разблокируем» дочерние джобы (их `RemainDeps` уменьшаем) и, если барьер у потомка разблокирован, добавляем их в `ReadyQueue_`.  
   - Уменьшаем счётчик текущих потоков `CurrentActiveThreads_`.  
   - Сигналим диспетчеру `pthread_cond_broadcast(&QueueCond_)`.

---

# 3. Используемые библиотеки и инструменты

1. **POSIX Threads (pthreads)**:  
   - `pthread_create()`, `pthread_detach()`,  
   - мьютексы (`pthread_mutex_t`),  
   - условные переменные (`pthread_cond_t`).  

2. **C++ STL**:  
   - `std::map`, `std::vector`, `std::queue`, `std::atomic`, `std::set`.  
   - `std::string`, `std::ostringstream`, `std::ifstream` для парсинга INI.  

3. **Google Test (GTest)**: для модульного тестирования.

4. **CMake**: для сборки проекта.

---

# 4. Реализация барьера (Barrier)

В классическом POSIX `pthread_barrier_t` нужно заранее знать точное число потоков, которые будут «дожидаться» барьера, и все они «встречаются» в одном месте.  
В данной задаче другая семантика:

- «Барьер» по имени **B** объединяет **несколько джоб**.  
- Зависимая джоба может стартовать только тогда, когда **все** джобы барьера **B** завершились.  

Поэтому мы реализуем **«countdown barrier»**: для каждой группы (barrier name) хранится:

- **`Remaining`**: число джоб из этого барьера, которые ещё не завершились.  
- Когда джоба заканчивается, вызывается `BarrierArrive(B)`, внутри которого `Remaining` уменьшается. Если достигает 0, делаем `pthread_cond_broadcast()`.  
- Любая зависимая джоба, если у неё барьер **B**, стартует только если `Remaining == 0`. Иначе она «ждёт» (фактически, не попадает в `ReadyQueue_` или ждёт, пока диспетчер не увидит, что барьер разблокирован).

Таким образом, «countdown barrier» реализован через `pthread_mutex_t + pthread_cond_t`.

---

# 5. Тестирование

1. **`ParseWithoutCycle`**  
   - Создаёт INI-файл без цикла (пример из условия: job=1,2,3 и т.д.)  
   - Проверяет, что парсинг прошёл (`ReadIni()` вернул `true`).  
   - Проверяет, что в `Jobs_` ожидаемое количество джоб (6).  
   - Проверяет, что `CheckCycle()` даёт `false`, `CheckStartFinish()` даёт `true`.  
   - Проверяет, что `MaxParallel_` == 4 (как в `[Parallel]`).  

2. **`ParseWithCycle`**  
   - Создаёт INI-файл, где есть цикл (например, 2->3 и 3->2).  
   - Убеждаемся, что `CheckCycle()` выдаёт `true`.  

3. **`ParseEmptyConfig`**  
   - Создаёт пустой файл (нет `[Jobs]`, `[Edges]`).  
   - `ReadIni()` откроет файл, но джоб не будет. `CheckStartFinish()` => `false`.  

4. **`ParseMultipleComponents`** 
   - Создаём INI-файл, где есть несколько вершин, но **часть** из них не связана с остальными (например, джобы 1->2, а джоба 3 сама по себе).  
   - `CheckCycle()` будет `false` (ведь 1->2 не образует цикл, а 3 вообще отдельно).  
   - `CheckStartFinish()` может дать `true`, если у всех вершин нет конфликтов (1 — start, 2 — finish, 3 — тоже start/finish «сам себе»).  
   - **`CheckSingleComponent()`** (новая функция) вернёт `false`, т.к. мы обнаружим, что есть как минимум две компоненты.  

5. **`BarrierCheck`** (пример расширенного теста на барьеры)  
   - Создаём небольшой INI-файл, где job=1 и job=2 принадлежат барьеру B1, а job=3 зависит от обоих (1->3, 2->3).  
   - Проверяем, что после парсинга `CheckCycle()` даёт `false`, `CheckStartFinish()` даёт `true` (start=1,2; finish=3), и в `Jobs_` действительно отразилась зависимость `3` от `1` и `2`.  

---

# 6. Вывод

1. **Задача «выполнена»**: мы можем читать DAG из INI, проверять цикл и наличие стартовых/финальных джоб, запускать потоки с ограничением \(N\) параллельно, останавливать при ошибке, и «держать» зависимые джобы, пока не освободится их барьер.  

2. **Самодельный барьер** реализован как «countdown» на каждую группу (по имени). Если `Remaining > 0`, то зависимые джобы ждут. Когда `Remaining == 0` → разблокировка.  

3. **Тесты** (Google Test) обеспечивают базовую уверенность, что парсер INI, логика обнаружения цикла, проверка start/finish работают корректно. Мы можем расширять тесты для более детальной проверки барьеров и параллелизма.

В целом, работа над проектом помогла глубже понять фундаментальные концепции параллелизма, синхронизации и DAG (включая подход к организации кода и парсинг конфига)
